import { Program, Provider, web3 } from '@project-serum/anchor';
import { PublicKey, Keypair } from '@solana/web3.js';
import { Token } from '@solana/spl-token';
import * as anchor from '@project-serum/anchor';
import { sendTransaction } from './connection-utils';
import { MintLayout, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Metadata, MasterEdition } from '@metaplex-foundation/mpl-token-metadata';
import { CANDY_MACHINE_PROGRAM_ID, TOKEN_METADATA_PROGRAM_ID } from '../program-ids';
import { getCandyMachineCreator, getTokenWallet } from "../utils/pda-utils"
import assert from 'assert';
import log from 'loglevel';

// These are now generated by Metaplex's Rust-to-JS code:
//   https://github.com/metaplex-foundation/metaplex-program-library/blob/master/candy-machine/js/src/generated/errors/index.ts
// but that library isn't quite usable yet, so we just hardcode them for now.
const errorMessages = [
  ['0x1770', 'Account does not have correct owner!'],
  ['0x1771', 'Account is not initialized!'],
  ['0x1772', 'Mint Mismatch!'],
  ['0x1773', 'Index greater than length!'],
  ['0x1774', 'Numerical overflow error!'],
  ['0x1775', 'Can only provide up to 4 creators to candy machine (because candy machine is one)!'],
  ['0x1776', 'Uuid must be exactly of 6 length'],
  ['0x1777', 'Not enough tokens to pay for this minting'],
  ['0x1778', 'Not enough SOL to pay for this minting'],
  ['0x1779', 'Token transfer failed'],
  ['0x177a', 'Candy machine is empty!'],
  ['0x177b', 'Candy machine is not live!'],
  ['0x177c', 'Configs that are using hidden uris do not have config lines, they have a single hash representing hashed order'],
  ['0x177d', 'Cannot change number of lines unless is a hidden config'],
  ['0x177e', 'Derived key invalid'],
  ['0x177f', 'Public key mismatch'],
  ['0x1780', 'No whitelist token present'],
  ['0x1781', 'Token burn failed'],
  ['0x1782', 'Missing gateway app when required'],
  ['0x1783', 'Missing gateway token when required'],
  ['0x1784', 'Invalid gateway token expire time'],
  ['0x1785', 'Missing gateway network expire feature when required'],
  ['0x1786', 'Unable to find an unused config line near your random number index'],
  ['0x1787', 'Invalid string'],
  ['0x1788', 'Suspicious transaction detected'],
  ['0x1789', 'Cannot Switch to Hidden Settings after items available is greater than 0'],
  ['0x178a', 'Incorrect SlotHashes PubKey'],
  ['0x178b', 'Incorrect collection NFT authority'],
  ['0x178c', 'Collection PDA address is invalid'],
  ['0x178d', 'Provided mint account doesn\'t match collection PDA mint'],
];

const _getWarningMesssage = (error: any) => {
  if (error.message) {
    for (const err of errorMessages) {
      if (error.message.indexOf(`: ${err[0]}`) >= 0) {
        return err[1];
      }
    }
  }
  return 'Minting failed! Please try again!';
};

const _createAssociatedTokenAccountInstruction = (
  associatedTokenAddress: PublicKey,
  payer: PublicKey,
  walletAddress: PublicKey,
  splTokenMintAddress: PublicKey,
) => {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
    { pubkey: walletAddress, isSigner: false, isWritable: false },
    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
    {
      pubkey: web3.SystemProgram.programId,
      isSigner: false,
      isWritable: false,
    },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    {
      pubkey: web3.SYSVAR_RENT_PUBKEY,
      isSigner: false,
      isWritable: false,
    },
  ];
  return new web3.TransactionInstruction({
    keys,
    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    data: Buffer.from([]),
  });
};

const _mintCandyMachineToken = async (
  provider: Provider,
  candyMachineAddress: PublicKey,
  recipientWalletAddress: PublicKey,
) => {
  assert(provider !== null, 'Expecting a valid provider!');
  assert(candyMachineAddress !== null, 'Expecting a valid candy machine address!');
  assert(recipientWalletAddress !== null, 'Expecting a valid recipient address!');
  const mint = Keypair.generate();
  const candyMachineProgramIDL = await Program.fetchIdl(CANDY_MACHINE_PROGRAM_ID, provider);
  const candyMachineProgram = new Program(candyMachineProgramIDL!, CANDY_MACHINE_PROGRAM_ID, provider);
  const userTokenAccountAddress = await getTokenWallet(recipientWalletAddress, mint.publicKey);
  const candyMachine: any = await candyMachineProgram.account.candyMachine.fetch(candyMachineAddress);
  const signers = [mint];
  const instructions = [
    anchor.web3.SystemProgram.createAccount({
      fromPubkey: recipientWalletAddress,
      newAccountPubkey: mint.publicKey,
      space: MintLayout.span,
      lamports: await candyMachineProgram.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),
      programId: TOKEN_PROGRAM_ID,
    }),
    Token.createInitMintInstruction(
      TOKEN_PROGRAM_ID,
      mint.publicKey,
      0,
      recipientWalletAddress,
      recipientWalletAddress,
    ),
    _createAssociatedTokenAccountInstruction(
      userTokenAccountAddress,
      recipientWalletAddress,
      recipientWalletAddress,
      mint.publicKey,
    ),
    Token.createMintToInstruction(
      TOKEN_PROGRAM_ID,
      mint.publicKey,
      userTokenAccountAddress,
      recipientWalletAddress,
      [],
      1,
    ),
  ];
  const metadataAddress = await Metadata.getPDA(mint.publicKey);
  const masterEdition = await MasterEdition.getPDA(mint.publicKey);
  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(candyMachineAddress);
  instructions.push(
    // @ts-ignore
    await candyMachineProgram.instruction.mintNft(creatorBump, {
      accounts: {
        candyMachine: candyMachineAddress,
        candyMachineCreator,
        payer: recipientWalletAddress,
        wallet: candyMachine.wallet,
        mint: mint.publicKey,
        metadata: metadataAddress,
        masterEdition,
        mintAuthority: recipientWalletAddress,
        updateAuthority: recipientWalletAddress,
        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
      },
    }),
  );
  log.info('About to send transaction with all the candy instructions!');
  const txid = await sendTransaction(provider, recipientWalletAddress, instructions, signers);
  log.info(`Sent transaction with id: ${txid} for mint: ${mint.publicKey.toString()}.`);
  return {
    txid,
    mint,
  };
};

const mintCandyMachineToken = async (
  provider: Provider,
  candyMachineAddress: PublicKey,
  recipientWalletAddress: PublicKey,
) : Promise<{txid?: string, mintAddress?: PublicKey, error?: any, errorMessage?: string }> => {
  try {
    const { txid, mint } = await _mintCandyMachineToken(provider, candyMachineAddress, recipientWalletAddress);
    return new Promise((resolve) => {
      provider.connection.onSignatureWithOptions(
        txid,
        async (notification, context) => {
          log.info(`Got notification of type: ${notification.type} from txid: ${txid}.`);
          if (notification.type === 'status') {
            const { result } = notification;
            if (!result.err) {
              resolve({ txid, mintAddress: mint.publicKey });
            }
          }
        },
        { commitment: 'processed' },
      );
    });
  } catch (error) {
    return { error, errorMessage: _getWarningMesssage(error) };
  }
};

export { 
  mintCandyMachineToken, 
  _getWarningMesssage 
};
